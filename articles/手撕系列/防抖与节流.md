# 防抖
1. 效果
对于短时间内连续触发的事件，在事件触发n秒后才执行，如果在这n秒内又触发了该事件，则以新的事件的时间为准。简单的说，就是在触发事件n秒内不再重复触发才会执行。

2. 代码实现
第一版：最朴实无华的版本

```js
function debounce(func, delay) {
    let timer = null;
    return function() {
        clearTimeout(timer);
        timer = setTimeout(func, delay);
    }
}
```

第二版：考虑到this会丢失

```js
function debounce(func, delay) {
    let timer = null;
    return function() {
        let that = this;
        clearTimeout(timer);
        timer = setTimeout(() => {
          func.apply(that);
        }, delay);
    }
}
```

第三版：再考虑到事件处理函数中会传入event对象

```js
function debounce(func, delay) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments
        clearTimeout(timer);
        timer = setTimeout(() => {
          func.apply(that, args);
        }, delay);
    }
}
```

第四版：先立即执行一次，再等n秒执行

```js
function debounce(func, delay, immediate) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments
        clearTimeout(timer);
        if (immediate) {
          let flag = !timer;
          timer = setTimeout(() => {
            timer = null;
          }, delay)
          if (flag) func.apply(that, args);
        } else {
          timer = setTimeout(() => {
            func.apply(that, args);
          }, delay);
        }  
    }
}
```